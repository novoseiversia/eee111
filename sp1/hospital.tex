\documentclass{article}



\title{EEE111 SP1 Documentation}
\author{Nile Jocson \textless{novoseiversia@gmail.com}\textgreater}
\date{\today}



\begin{document}
	\maketitle
		\pagebreak



	\tableofcontents
		\pagebreak



	\section{Overview}
		The program is a CLI supply and inventory monitoring program based on
		the EEE111 SP1 specifications provided. It accepts the following commands:

		\begin{itemize}
			\item \verb|<file_name:str> needed_now| --- prints out the amount of items
			needed to fulfill the item shortage for the current day.
			\item \verb|<file_name:str> needed_in <X:int>| --- prints out the amount of items
			needed to fulfill the item shortage for the following \verb|X| days.
			\item \verb|<file_name:str> runs_out| --- prints out the first item to run out, and
			in how many days it will.
			\item \verb|<file_name:str> run_outs| --- prints out the first \verb|N| items to run
			out, and in how many days they will.
			\item \verb|help| prints out the help text.
			\item \verb|exit| exits the program.
		\end{itemize}

		The program will accept commands indefinitely, exiting only when the \verb|exit| command is
		entered. If an invalid command is entered, the program prints out the help text.

		\pagebreak

	\section{Parsing}
		Parsing utilities were created in order to simplify parsing inputs. This eliminates the
		need for long if-elif-else chains and complicated string comparisons, and instead
		abstracts them into an easy-to-use API\@. This API consists of two dataclasses and
		two functions:

		\begin{verbatim}
			@dataclass
			class TransformInfo:
				convert : type | Callable
				position: int

			@dataclass
			class ParseRule:
				transforms : list[TransformInfo]
				find_string: str | None = None

			def parse_rules(
				rules: list[ParseRule],
				args : list[str]
			) -> list[Any] | None

			def parse_rulesets(
				rulesets: list[list[ParseRule]],
				args    : list[str],
				default : list[Any]
			) -> list[Any]:
		\end{verbatim}

		The inner workings of this API can be broken down into three processes.

		\subsection{Input}
			\subsubsection{Arguments}
				The parsing API uses input in the form of \verb|list[str]|. It does not handle
				actual program IO, nor does it handle the splitting of the input lines. This
				input type is derived from the return type of \verb|str.split()|, which is
				used to split user input by a specified delimiter. From now on, the term
				``arguments'' will be used to refer to user input with type \verb|list[str]|
				given to the parsing API\@.

			\subsubsection{Rules}
				A rule determines if an argument is valid. It specifies a list of transforms which
				contains either types that the argument must be convertible to, or functions of
				which the argument must be a valid parameters of. In addition, it may also specify
				a string which the argument must be equal to; this is used to disambiguate between
				command names. If any one of these were not satisfied, the argument is invalid. A
				rule is defined with the \verb|ParseRule| dataclass.

				Most programs however, take in multiple arguments, thus requiring multiple rules.
				Rules are simply a \verb|list[ParseRule]|, where each rule has a corresponding
				argument with the same index. Each element is validated against its corresponding
				rule. If any one rule is not satisfied, the whole argument list is invalid.

				Here are some examples of rules, and their valid and invalid arguments:

				\begin{center}
					\begin{tabular}{c c c}
						Rules & Valid & Invalid \\
						\\
							int &
							``5'' &
							``a''
						\\
							int, int &
							``5'', ``10'' &
							``5'', ``a''
						\\
							``add'', int, int &
							``add'', ``5'', ``10'' &
							``sub'', ``5'', ``10''
						\\
							``abs'', int &
							``abs'', ``-5.4'' &
							``absv'', ``-5.4''
						\\
					\end{tabular}
				\end{center}

				If the arguments given to \verb|parse_rules| are invalid, it returns \verb|None|.

		\subsection{Output}
			As said before, rules specify a list of transforms. These transforms are defined
			with the \verb|TransformInfo| dataclass. A transform consists of either a type or
			a function, and an integer. The argument corresponding to the rule containing the
			transforms is either converted to the given type or fed into the given function,
			the results of which are inserted into a list at the index indicated by the given
			integer.

			Here are some examples of rules with transforms, and their input and outputs:

			\begin{center}
				\begin{tabular}{c c c}
					Rules & Input & Output \\
					\\
						\{[\{int, 1\}]\}, \{[\{float, 0\}]\}, \{[\{float, 2\}]\} &
						``10.0'', ``5'', ``6'' &
						5.0, 10, 2.0
					\\
						\{[\{int, 0\}, \{float, 1\}, \{str, 2\}]\} &
						``94'' &
						94, 94.0, ``94''
					\\
						\{[\{str, 0\}], ``abs''\}, \{[\{float, 1\}]\} &
						``abs'', ``94'' &
						``abs'', 94.0
					\\
				\end{tabular}
			\end{center}

			If the arguments given to \verb|parse_rules| are valid, it returns a \verb|list[Any]|
			of the transformed arguments.

			\subsection{Rulesets}
			While a rule is for a single argument, and rules are for multiple arguments, rulesets
			are for multiple commands. A ruleset is simply a \verb|list[list[ParseRule]]|, or a
			list of lists of rules. Rulesets allow the given arguments to be parsed against
			multiple different rules, and transforming them against the first rules that
			successfully validate them. This process is governed by the \verb|parse_rulesets|
			function.

			For example, given the ruleset

			\begin{center}
				\item ``add'', int, int
				\item ``sub'', int, int
				\item ``abs'', float
			\end{center}

			and the arguments

			\begin{center}
				\item ``add'', ``5'', ``8''
			\end{center}

			the selected rules and its output will be

			\begin{center}
				\item ``add'', int, int
				\item ``add'', 5, 8
			\end{center}

			If no rules successfully validate the arguments, the \verb|default| argument of
			\verb|parse_rules| is returned.

\end{document}
