\documentclass{article}



\title{EEE111 SP1 Documentation}
\author{Nile Jocson \textless{novoseiversia@gmail.com}\textgreater}
\date{October 11, 2024}



\begin{document}
	\maketitle
		\pagebreak



	\tableofcontents
		\pagebreak



	\section{Introdution}
		This is the documentation for my EEE111 SP1 submission. Included here is
		documentation for each user-defined function, rationales for how the logic
		is written, how user commands are executed, etc. A reference for each user-defined
		function and class is also included.
		\newpage



	\section{Documentation}
		\subsection{Overview of the program}\label{overview-of-the-program}
			The program is a CLI supply and inventory monitoring program,
			created for a hospital, based on the EEE111 SP1 specifications
			provided. It accepts user input, and allows the following commands
			(in docopt form):

			\begin{verbatim}
			<file_name:str> needed_now
			<file_name:str> needed_in <X:int>
			<file_name:str> runs_out
			<file_name:str> <N:int> run_outs
			help
			exit
			\end{verbatim}

			\begin{itemize}
				\item \verb|<file_name:str> needed_now| prints out the amount needed to fulfill
			the item shortage for the current day.

				\item \verb|<file_name:str needed_in <X:int>| prints out the amount needed to
				fulfill the item shortage for the following \verb|X| days.

				\item \verb|<file_name:str> runs_out| prints out the first item to run out, and
				in how many days it will\footnote{
					These commands will sort in this order in the case of conflicts:
					by amount of days to run out (ascending),
					by amount of deficit (descending),
					and by lexical order of their names (ascending).
				}.

				\item \verb|<file_name:str> run_outs| prints out the first \verb|N| items to run
				out, and in how many days they will\footnotemark[\value{footnote}].

				\item \verb|help| prints out the help text.

				\item \verb|exit| exits the program.
			\end{itemize}

		\subsection{Input file}\label{input-file}
			The commmands \verb|needed_now|, \verb|needed_in|, \verb|runs_outs|, and
			\verb|run_outs| takes in a \verb|<file_name:str>| argument, which is a
			string corresponding to the filename of the CSV file containing the hospital's
			supply database. This file can have a variable amount of rows, but the amount of
			columns is fixed. These columns are as follows:

			\begin{enumerate}
				\item Item name: str
				\item Item current amount: int
				\item Item daily usage: int
			\end{enumerate}

		\subsection{Parser logic}\label{parser-logic}
			The program relies on a set of enums and functions in order to make it
			easier to parse user input into commands and their arguments, not relying on tedious
			chains of if-elif-else statements. These comprise the parser logic of the program.
			The core of this logic is the function

			\begin{verbatim}
				parse_rules(
					input_rules: InputRules,
					output_rules: OutputRules,
					args: list[str]
				) -> list[Any] | None
			\end{verbatim}

			which parses the given string arguments and outputs a validated, converted and
			reordered arguments, based on the given input and output rules. This makes it
			extremely easy to validate user input, and parse them into well-defined lists
			of commands and their arguments. The logic of this function can be broken down into
			two steps:

			\subsubsection{Application of input rules}
				An input rule can be either a type or a string. If it is a type, then that type
				must be constructable from the argument under that rule. If it is a string, then
				that string must be the same as the argument under that rule. Otherwise, the
				argument is invalid. For example:

				\begin{itemize}
					\item For the input rule \verb|int|, the argument \verb|"Hello"| is invalid,
					since that cannot be converted into an integer. However, \verb|"500"| is
					valid.
					\item For the input rule \verb|"exit"|, the argument \verb|"exita"| is invalid,
					since the two strings are not equal. However, \verb|"exit"| is valid.
				\end{itemize}

				For a list of input rules \verb+InputRules = list[type | str]+, the list of
				arguments must be the same length, and each argument must be valid with its
				corresponding input rule, for the list of arguments to be valid. For example:

				\begin{itemize}
					\item For the input rules \verb|["exit"]|, the arguments \verb|["exit", "1"]| are
					invalid, since the amount of arguments is not equal to the amount of input rules.
					However, \verb|["exit"]| is valid.
					\item For the input rules \verb|[int, str]|, the arguments \verb|["Hello", "World"]|
					are invalid, since \verb|"Hello"| is not an integer. However, \verb|["500", "World"]|
					is valid.
					\item For the input rules \verb|["abs", int]|, the arguments \verb|["absv", "-5"]|
					are invalid, since \verb|"absv"| is not the same as \verb|"abs"|. However,
					\verb|["abs", "-5"]| is valid.
				\end{itemize}

				If all string arguments are valid, then a list is created of the converted arguments based
				on the input rules. For example:

				\begin{itemize}
					\item With the input rules \verb|["add", int, int]|, the arguments \\
					\verb|["add", "5", "8"]| are converted into \verb|["add", 5, 8]|.
					\item With the input rules \verb|["floor", float]|, the arguments \\
					\verb|["floor", "4.8"]| are converted into \verb|["floor", 4.8]|.
				\end{itemize}

				These converted arguments then move on to the next step:

			\subsubsection{Application of output rules}
				An output rule can either be an integer or a tuple of an integer and a type, i.e.
				\verb+OutputRules = list[int | tuple[int, type]]+. The integer
				corresponds to an index in the argument list, and if a type is specified, then the element
				in that index is converted into that type. The converted element is then appended into the
				list of fully processed arguments which will be returned from the function. For example:

				\begin{itemize}
					\item The output rules \verb|[2, 1, 0]| will rearrange \verb|["A", "B", "C"]| into \\
					\verb|["C", "B", "A"]|.
					\item The output rules \verb|[2, [1, str], 0]| will rearrange and convert \\
					\verb|[5, 8, 13]| into \verb|[13, "8", 5]|.
				\end{itemize}

				This rearranged list is then returned from the function.

			\subsubsection{Rulesets}
				Generally, and especially in this program, user input is not validated only using one set of
				input and output rules. Instead, since this program needs to handle 6 different commands,
				it needs to check against 6 different sets of input and output rules, or rulesets, i.e.
				\verb|RuleSet = tuple[InputRules, OutputRules]|. In order to make this a trivial task, another
				parse function has been defined

				\begin{verbatim}
					parse_rulesets(
						rulesets: list[RuleSet],
						args: list[str],
						default: list[Any]
					) -> list[Any]
				\end{verbatim}

				which takes in a list of arguments and tries to parse them against the given rulesets. The first
				valid parse is returned, or if all parses were invalid, then the value of the \verb|default|
				parameter is returned instead.

		\subsection{Database logic}
			\subsubsection{Deserializing the database}
				Some classes, aliases and functions have also been defined in order to make it easier to handle
				the information inside the supply database. The function

				\begin{verbatim}
					parse_database(filename: str) -> SupplyDatabase
				\end{verbatim}

				Opens and reads the CSV file denoted by the given filenme. It then parses the file line by line using
				the docopt string

				\begin{verbatim}
					<item_name:int>
					<item_current_amount:int>
					<item_daily_usage:int>
				\end{verbatim}

				reusing the parser logic in~\ref{parser-logic} and populates a \verb|SupplyDatabase| instance, and
				returns it. A \verb|SupplyDatabase| is a \verb|dict[str, StockInfo]|, which contains stock information
				for each item. A \verb|StockInfo| is then defined as follows:

				\begin{verbatim}
					@dataclass
					class StockInfo:
						quantity      : int
						daily_usage   : int
						remaining_days: int
						deficit       : int
				\end{verbatim}

				A tuple was not used for the purpose of storing stock information since there is no way to
				distinguish between the different values other than using their indices. By using dataclasses,
				names can be given to the elements, making the source code more readable.



\end{document}
