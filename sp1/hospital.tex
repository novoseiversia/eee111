\documentclass{article}



\title{EEE111 SP1 Documentation}
\author{Nile Jocson \textless{novoseiversia@gmail.com}\textgreater}
\date{\today}



\begin{document}
	\maketitle
		\pagebreak



	\tableofcontents
		\pagebreak



	\section{Overview}\label{overview}
		The program is a CLI supply and inventory monitoring program based on
		the EEE111 SP1 specifications provided. It accepts the following commands:

		\begin{itemize}
			\item \verb|<file_name:str> needed_now| --- prints out the amount of items
			needed to fulfill the item shortage for the current day.
			\item \verb|<file_name:str> needed_in <X:int>| --- prints out the amount of items
			needed to fulfill the item shortage for the following \verb|X| days.
			\item \verb|<file_name:str> runs_out| --- prints out the first item to run out, and
			in how many days it will.
			\item \verb|<file_name:str> run_outs| --- prints out the first \verb|N| items to run
			out, and in how many days they will.
			\item \verb|help| prints out the help text.
			\item \verb|exit| exits the program.
		\end{itemize}

		The program will accept commands indefinitely, exiting only when the \verb|exit| command is
		entered. If an invalid command is entered, the program prints out the help text.

		\pagebreak

	\section{Parsing}
		Parsing utilities were created in order to simplify parsing inputs. This eliminates the
		need for long if-elif-else chains and complicated string comparisons, and instead
		abstracts them into an easy-to-use API\@. This API consists of two dataclasses and
		two functions:

		\begin{verbatim}
			@dataclass
			class TransformInfo:
				convert : type | Callable
				position: int

			@dataclass
			class ParseRule:
				transforms : list[TransformInfo]
				find_string: str | None = None

			def parse_rules(
				rules: list[ParseRule],
				args : list[str]
			) -> list[Any] | None

			def parse_rulesets(
				rulesets: list[list[ParseRule]],
				args    : list[str],
				default : list[Any]
			) -> list[Any]:
		\end{verbatim}

		The inner workings of this API can be broken down into three processes.

		\subsection{Input}
			The parsing API uses input in the form of \verb|list[str]|. It does not handle
			actual program IO, nor does it handle the splitting of the input lines. This
			input type is derived from the return type of \verb|str.split()|, which is
			used to split user input by a specified delimiter. From now on, the term
			``arguments'' will be used to refer to user input with type \verb|list[str]|
			given to the parsing API\@.

			A rule determines if an argument is valid. It specifies a list of transforms which
			contains either types that the argument must be convertible to, or functions of
			which the argument must be a valid parameters of. In addition, it may also specify
			a string which the argument must be equal to; this is used to disambiguate between
			command names. If any one of these were not satisfied, the argument is invalid. A
			rule is defined with the \verb|ParseRule| dataclass.

			Most programs however, take in multiple arguments, thus requiring multiple rules.
			Rules are simply a \verb|list[ParseRule]|, where each rule has a corresponding
			argument with the same index. Each element is validated against its corresponding
			rule. If any one rule is not satisfied, the whole argument list is invalid.

			Here are some examples of rules, and their valid and invalid arguments:

			\begin{center}
				\begin{tabular}{|c|c|c|}
					\hline
					Rules & Valid & Invalid
					\\ \hline
						\verb|int| &
						\verb|"5"| &
						\verb|"a"|
					\\ \hline
						\verb|int|, \verb|int| &
						\verb|"5", "10"| &
						\verb|"5", "a"|
					\\ \hline
						\verb|"add", int, int| &
						\verb|"add", "5", "10"| &
						\verb|"sub", "5", "10"|
					\\ \hline
						\verb|"abs", int| &
						\verb|"abs", "-5.4"| &
						\verb|"absv", "-5.4"|
					\\\hline
				\end{tabular}
			\end{center}

			If the arguments given to \verb|parse_rules| are invalid, it returns \verb|None|.

		\subsection{Output}
			As said before, rules specify a list of transforms. These transforms are defined
			with the \verb|TransformInfo| dataclass. A transform consists of either a type or
			a function, and an integer. The argument corresponding to the rule containing the
			transforms is either converted to the given type or fed into the given function,
			the results of which are inserted into a list at the index indicated by the given
			integer.

			Here are some examples of rules with transforms, and their input and outputs:

			\begin{center}
				\begin{tabular}{|c|c|c|}
					\hline
					Rules & Input & Output
					\\ \hline
						\begin{tabular}{@{}c@{}}
							\verb|{[{int, 1}]},| \\
							\verb|{[{float, 0}]},| \\
							\verb|{[{float, 2}]}|
						\end{tabular} &
						\verb|"10.0", "5", "6"| &
						\verb|5.0, 10, 6.0|
					\\ \hline
						\begin{tabular}{@{}c@{}}
							\verb|{[{int, 1}],| \\
							\verb|[{float, 0}],| \\
							\verb|[{float, 2}]}|
						\end{tabular} &
						\verb|"94"| &
						\verb|94, 94.0, "94"|
					\\ \hline
						\begin{tabular}{@{}c@{}}
							\verb|{[{str, 0}], "abs"},| \\
							\verb|{[{float, 1}]}| \\
						\end{tabular} &
						\verb|"abs", "94"| &
						\verb|"abs", 94.0|
					\\ \hline
				\end{tabular}
			\end{center}

			If the arguments given to \verb|parse_rules| are valid, it returns a \verb|list[Any]|
			of the transformed arguments.

		\subsection{Rulesets}
			While a rule is for a single argument, and rules are for multiple arguments, rulesets
			are for multiple commands. A ruleset is simply a \verb|list[list[ParseRule]]|, or a
			list of lists of rules. Rulesets allow the given arguments to be parsed against
			multiple different rules, and transforming them against the first rules that
			successfully validate them. This process is governed by the \verb|parse_rulesets|
			function.

			For example, given the ruleset:

			\begin{center}
				\verb|"add", int, int| \\
				\verb|"sub", int, int| \\
				\verb|"abs", float|    \\
			\end{center}

			the following arguments will be validated by the selected rule, returning the outputs:

			\begin{center}
				\begin{tabular}{|c|c|c|c|}
					\hline
					Arguments & Selected & Output
					\\ \hline
						\verb|"add", "5", "8"| &
						\verb|"add", int, int| &
						\verb|"add", 5, 8|
					\\ \hline
						\verb|"sub", "90.4", "3.13"| &
						\verb|"sub", int, int| &
						\verb|"sub", 90, 3|
					\\ \hline
						\verb|"abs", "-144"| &
						\verb|"abs", float| &
						\verb|"abs", -144.0|
					\\ \hline
						\verb|"sin", "90"| &
						\verb|None| &
						\verb|default|
					\\ \hline
				\end{tabular}
			\end{center}

			Note that if no rules successfully validate the arguments, the \verb|default| argument of
			\verb|parse_rules| is returned.

		\pagebreak

	\section{Database}
		The database used by this program consists of items, one of which then consists of a name,
		a quantity, and a daily usage. In order to make database handling simple, an API of one
		dataclass, two aliases, and three functions were created.

		\begin{verbatim}
			@dataclass
			class StockInfo:
				quantity      : int
				daily_usage   : int
				remaining_days: int
				deficit       : int

			type SupplyDatabase = dict[str, StockInfo]
			type SortedSupplyDatabase = list[tuple[str, StockInfo]]

			def parse_database(
				filename: str
			) -> SupplyDatabase

			def supply_database_compare(
				left: tuple[str, StockInfo],
				right: tuple[str, StockInfo]
			) -> int

			def sort_supply_database(
				database: SupplyDatabase
			) -> SortedSupplyDatabase
		\end{verbatim}

		This API can be broken down into two parts.

		\subsection{Formats}
			The parsed format of the database is defined by the \verb|SupplyDatabase| alias. This
			alias is dictinary consisting of an \verb|str| key corresponding to the item name and a
			\verb|StockInfo| value which includes the remaining two item values, as well as another
			two computed values:

			\begin{itemize}
				\item \verb|remaining_days| is how many days it will take for the stock of the item
				to run out, given the daily usage.
				\item \verb|deficit| is how much of the item should be acquired in order to satisfy
				the shortage on the day it runs out.
			\end{itemize}

			The input format of the database is a comma-separated values (CSV) file with a variable
			amount of rows corresponding to each item, and three columns corresponding to each item
			value.

			The conversion from the input format into the parsed format of the database is handled
			by \verb|parse_database|. This function takes in the filename of the input file, parses
			it, and returns a populated \verb|SupplyDatabase| instance, including the two
			calculated values. The input file can be parsed by splitting each line using commas as
			the delimiter, then using \verb|parse_args| with the rules

			\begin{center}
				\verb|{[{str, 0}]}, {[{int, 1}]}, {[{int, 2}]}|
			\end{center}

			If the input file format is invalid, \verb|parse_database| raises a
			\verb|RuntimeError|.

		\subsection{Sorting}
			Since Python does not have a built-in sorted dictionary (unlike C++, with its
			\verb|std::map|), the \verb|SupplyDatabase| must be manually sorted in order to support
			some of the commands specified in~\ref{overview}. A custom sorting order is required by
			the specification:

			\begin{itemize}
				\item \verb|remaining_days|, in ascending order
				\item \verb|deficit|, in descending order
				\item \verb|name|, in ascending lexicographic order
			\end{itemize}

			In order to sort using this order, a custom comparator is needed. This custom
			comparator is the \verb|supply_database_compare| function. This comparator function
			follows the specification or \verb|functools.cmp_to_key|; if the item on the left is
			less-than, equal, or greater-than the item on the right, the function should return
			a negative value, zero, or a positive value, respectively.

			The convenience function \verb|sort_supply_database| simply calls \verb|sorted| on
			the \verb|SupplyDatabase| with \verb|supply_database_compare| as the comparator. The
			result of this sort is defined by the \verb|SortedSupplyDatabase| alias, which is a
			list of tuples of the item values. This change in container type is required since
			the \verb|SupplyDatabase|, which is an underlying \verb|dict|, cannot preserve the
			order of its elements, and as such cannot be sorted on its own.

\end{document}
